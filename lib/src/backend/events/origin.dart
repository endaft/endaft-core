import 'package:collection/collection.dart';
import 'package:json_annotation/json_annotation.dart';

import '../../contracts/all.dart';

part 'origin.g.dart';

const _envVarPrefix = 'X-Env-';

/// A response message from a CloudFront Origin Request Event
@JsonSerializable()
class CloudFrontOriginResponse extends AppContract {
  CloudFrontOriginResponse({
    this.body,
    this.bodyEncoding = CloudFrontBodyEncoding.text,
    CloudFrontHeaders? headers,
    this.status = 200,
    this.statusDescription = "OK",
  }) {
    this.headers = headers ??
        CloudFrontHeaders(
          headers: <String, List<Map<String, String>>>{},
        );
  }

  /// The body, if any, that you want CloudFront to return in the generated response.
  final String? body;

  /// The encoding for the value that you specified in the `body`. The only valid encodings are `text` and `base64`.
  /// If you include `body` in the `response` object but omit `bodyEncoding`, CloudFront treats the body as `text`.
  /// If you specify `bodyEncoding` as `base64` but the body is not valid `base64`, CloudFront returns an error.
  final CloudFrontBodyEncoding bodyEncoding;

  /// Headers that you want CloudFront to return in the generated response. Note the following:
  /// - The keys in the `headers` object are lowercase versions of standard HTTP header names. Using lowercase keys gives you case-insensitive access to the header values.
  /// - Each header (for example, `headers["accept"]` or `headers["host"]`) is an array of key-value pairs. For a given header, the array contains one key-value pair for each value in the generated response.
  ///   - `key` (optional) is the case-sensitive name of the header as it appears in an HTTP request; for example, `accept` or `host`.
  /// - Specify `value` as a header value.
  /// - If you do not include the header key portion of the key-value pair, `Lambda@Edge` will automatically insert a header
  /// key using the header name that you provide. Regardless of how you've formatted the header name, the header key that is
  /// inserted automatically will be formatted with initial capitalization for each part, separated by hyphens (-).
  ///
  /// For example, you can add a header like the following, without a header key: `'content-type': [{ value: 'text/html;charset=UTF-8' }]`
  /// In this example, `Lambda@Edge` creates the following header key: `Content-Type`.
  late final CloudFrontHeaders headers;

  /// The HTTP status code that you want CloudFront to use for the following:
  /// - Return in the response
  /// - Cache in the CloudFront edge cache, when the response was generated by a function that was triggered by an origin request event
  /// - Log in CloudFront Configuring and Using Access Logs
  ///
  /// If the `status` value isn't between `200` and `599`, CloudFront returns an error to the viewer.
  final int status;

  /// The description that you want CloudFront to return in the response, to accompany the HTTP status code.
  /// You don't need to use standard descriptions, such as OK for an HTTP status code of 200.
  final String? statusDescription;

  factory CloudFrontOriginResponse.fromJson(Map<String, dynamic> json) =>
      _$CloudFrontOriginResponseFromJson(json);

  @override
  Map<String, dynamic> toJson() => _$CloudFrontOriginResponseToJson(this);
}

@JsonSerializable()
class CloudFrontOriginRequestEvent extends AppContract {
  CloudFrontOriginRequestEvent({required this.records}) {
    environment = _loadEnvironment(records);
  }

  final List<CloudFrontRecords> records;

  @JsonKey(includeFromJson: false, includeToJson: false)
  late final UnmodifiableMapView<String, String> environment;

  bool hasHeader(String key) {
    return records.firstOrNull?.cf.request.hasHeader(key) ?? false;
  }

  String? getHeader(String key, [String? fallback]) {
    return records.firstOrNull?.cf.request.getHeader(key) ?? fallback;
  }

  bool hasEnv(String key) {
    final envKey = '$_envVarPrefix$key';
    return environment.containsKey(envKey);
  }

  String? getEnv(String key, [String? fallback]) {
    final envKey = '$_envVarPrefix$key';
    return hasEnv(key) ? environment[envKey] : fallback;
  }

  bool? getEnvBool(String key, [bool? fallback]) {
    return hasEnv(key) && getEnv(key) != null
        ? getEnv(key)?.toLowerCase() == 'true'
        : fallback;
  }

  num? getEnvNum(String key, [num? fallback]) {
    return hasEnv(key) && getEnv(key) != null
        ? num.parse(getEnv(key)!)
        : fallback;
  }

  static UnmodifiableMapView<String, String> _loadEnvironment(
    List<CloudFrontRecords> records,
  ) {
    final headers = records.firstOrNull?.cf.request.origin.values.firstOrNull
        ?.customHeaders.flattened;
    if (headers == null || headers.isEmpty) {
      return UnmodifiableMapView<String, String>(<String, String>{});
    }
    return UnmodifiableMapView<String, String>(
      Map<String, String>.fromEntries(
        headers.keys
            .where((k) => k.startsWith(_envVarPrefix))
            .map((k) => MapEntry(k, headers[k]!)),
      ),
    );
  }

  CloudFrontOriginRequestEvent redirectTo(String uriPath) {
    return CloudFrontOriginRequestEvent(
      records: records.map((e) => e.redirectTo(uriPath)).toList(),
    );
  }

  factory CloudFrontOriginRequestEvent.fromJson(Map<String, dynamic> json) =>
      _$CloudFrontOriginRequestEventFromJson(json);

  @override
  Map<String, dynamic> toJson() => _$CloudFrontOriginRequestEventToJson(this);
}

@JsonSerializable()
class CloudFrontRecords extends AppContract {
  CloudFrontRecords({required this.cf});

  final CloudFront cf;

  CloudFrontRecords redirectTo(String uriPath) {
    return CloudFrontRecords(cf: cf.redirectTo(uriPath));
  }

  factory CloudFrontRecords.fromJson(Map<String, dynamic> json) =>
      _$CloudFrontRecordsFromJson(json);

  @override
  Map<String, dynamic> toJson() => _$CloudFrontRecordsToJson(this);
}

@JsonSerializable()
class CloudFront extends AppContract {
  CloudFront({required this.config, required this.request});

  final CloudFrontConfig config;
  final CloudFrontRequest request;

  CloudFront redirectTo(String uriPath) {
    return CloudFront(config: config, request: request.redirectTo(uriPath));
  }

  factory CloudFront.fromJson(Map<String, dynamic> json) =>
      _$CloudFrontFromJson(json);

  @override
  Map<String, dynamic> toJson() => _$CloudFrontToJson(this);
}

@JsonSerializable()
class CloudFrontRequest extends AppContract {
  CloudFrontRequest({
    required this.clientIp,
    required this.headers,
    required this.method,
    required this.origin,
    required this.queryString,
    required this.uri,
    required this.body,
  });

  final String clientIp;
  final CloudFrontHeaders headers;
  final String method;
  final Map<String, CloudFrontOrigin> origin;
  final String queryString;
  final String uri;
  final CloudFrontRequestBody body;

  bool hasHeader(String name) {
    return headers.flattened.containsKey(name);
  }

  String? getHeader(String name) {
    return headers.flattened[name];
  }

  CloudFrontRequest redirectTo(String uriPath) {
    return CloudFrontRequest(
      clientIp: clientIp,
      headers: headers,
      method: method,
      origin: origin,
      queryString: queryString,
      uri: uriPath,
      body: body,
    );
  }

  factory CloudFrontRequest.fromJson(Map<String, dynamic> json) =>
      _$CloudFrontRequestFromJson(json);

  @override
  Map<String, dynamic> toJson() => _$CloudFrontRequestToJson(this);
}

enum CloudFrontBodyAction {
  @JsonValue('readOnly')
  readOnly,
  @JsonValue('replace')
  replace,
}

enum CloudFrontBodyEncoding {
  @JsonValue('base64')
  base64,
  @JsonValue('text')
  text,
}

@JsonSerializable()
class CloudFrontRequestBody extends AppContract {
  final bool inputTruncated;
  final CloudFrontBodyAction action;
  final CloudFrontBodyEncoding encoding;
  final String? data;

  CloudFrontRequestBody({
    required this.inputTruncated,
    required this.action,
    required this.encoding,
    required this.data,
  });

  factory CloudFrontRequestBody.fromJson(Map<String, dynamic> json) =>
      _$CloudFrontRequestBodyFromJson(json);

  @override
  Map<String, dynamic> toJson() => _$CloudFrontRequestBodyToJson(this);
}

@JsonSerializable()
class CloudFrontOrigin extends AppContract {
  CloudFrontOrigin({
    required this.customHeaders,
    required this.domainName,
    required this.keepAliveTimeout,
    required this.path,
    required this.port,
    required this.protocol,
    required this.readTimeout,
    required this.sslProtocols,
  });

  final CloudFrontHeaders customHeaders;
  final String domainName;
  final int? keepAliveTimeout;
  final String path;
  final int? port;
  final String? protocol;
  final int? readTimeout;
  final List<String>? sslProtocols;

  factory CloudFrontOrigin.fromJson(Map<String, dynamic> json) =>
      _$CloudFrontOriginFromJson(json);

  @override
  Map<String, dynamic> toJson() => _$CloudFrontOriginToJson(this);
}

@JsonSerializable()
class CloudFrontHeaders extends AppContract {
  CloudFrontHeaders({required this.headers});

  final Map<String, List<Map<String, String>>> headers;

  Map<String, String> get flattened {
    return headers.map((key, value) => MapEntry(key, value.first.values.first));
  }

  factory CloudFrontHeaders.fromJson(Map<String, dynamic> json) =>
      _$CloudFrontHeadersFromJson(json);

  @override
  Map<String, dynamic> toJson() => _$CloudFrontHeadersToJson(this);
}

@JsonSerializable()
class CloudFrontConfig extends AppContract {
  CloudFrontConfig({
    required this.distributionDomainName,
    required this.distributionId,
    required this.eventType,
    required this.requestId,
  });

  final String requestId;
  final String eventType;
  final String distributionId;
  final String distributionDomainName;

  factory CloudFrontConfig.fromJson(Map<String, dynamic> json) =>
      _$CloudFrontConfigFromJson(json);

  @override
  Map<String, dynamic> toJson() => _$CloudFrontConfigToJson(this);
}
